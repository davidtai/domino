# seldom.js
# Copyright (c) 2015 David Tai
#
#Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

# Requires Jquery

_               = require 'underscore'

diff            = require 'virtual-dom/diff'
patch           = require 'virtual-dom/patch'
createElement   = require 'virtual-dom/create-element'

EventEmitter    = require './event'
premade         = require './premade'

module.exports = {}

if !$ && !jquery
  throw new Error('seldom.js requires $/jquery')

# A FlowEvent is a custom event type generated by a FlowController's trigger method
class FlowEvent
  # name of event
  name: ''
  # data of event
  data: null

# A FlowState is a dictionary of meta data with some special fields (listed below)
class FlowState
  # stale is stale data value before a flow is executed
  stale: null
  # dom is the root dom object
  dom: null
  # event is a FlowEvent object if flow is triggered by an event
  event: null

  constructor: (@stale, @dom, @event)->

scheduledToRenderFlowControllers = []

module.exports.MainLoop =
  start: ()->
    render = ()->
      # Create temporary variable to hold FlowControllers to render
      flowControllers = []
      for scheduledToRenderFlowController in scheduledToRenderFlowControllers
        flowControllers.push scheduledToRenderFlowController

      # Start looping through all FlowControllers,
      for flowController in flowControllers
        if flowController._needsRender
          flowController.trigger 'render'
        # # Add children to FlowControllers needing Rendering
        # for childFlowController in flowController.children
        #   flowControllers.push childFlowController

      scheduledToRenderFlowControllers.length = 0

      requestAnimationFrame render
    requestAnimationFrame render

# A FlowController maps events to 'flows' which are basically a list monadic binds
# to be executed by the FlowController monad
module.exports.FlowController = class FlowController extends EventEmitter
  # jquery/css selector for finding an element in a parent
  selector: ''

  # is a root FlowController
  root: false

  # original options passed in
  options: null

  # currently rendered HScript root
  _h: null

  # most recently rendered HScript root
  _lastH: null

  # Last rendered dom element
  _dom: null

  # Member storing the last data rendered, get this using .data
  _data: null

  # child flow controllers
  children: null

  # Array of dom events to bind, generated from flows
  # Also could be used in unbinding dom events
  _domEvents: null

  # internally used by scheduling render
  _needsRender: false

  # Define an event to flow mapping using Backbone style eventing syntax
  # Events can either be composed of a event name or an event name with a css selector.
  # The first case is for programmatically triggered events.  The second case is for
  # user driven events from the rendered dom.
  #
  # Flows are either a single function or a collection (array) of functions each
  # with the form of (data, state) -> returns processedData
  # where
  #  - 'data' is either the pre-Flow data passed when passed into the first function
  #    or the processedData from the previous function
  #  - 'state' contains a FlowState object
  #  - 'processedData' is the data to pass into the next function
  #    (typically a modified version of data)
  #
  # Each function's @ is set to its flow controller.  Note: It is ill-advised to add state
  # onto @, instead stick state onto the state object to make it scoped to the duration of
  # each flow.  @ is generally used to trigger things.
  #
  # Example
  # flows:
  #   'optional-namespace.event-name css.selector': userTriggedThing,
  #   'handle-input': [
  #     sanitize,
  #     validate,
  #     render,
  #   ]
  #
  flows:
    set: premade.set

  # Used internally to store compiled flow functions
  _flows: null

  constructor: (options = {})->
    @options    = options
    @selector   = options.selector || @selector
    data_       = options.data || {}
    @root       = options.root || @root
    @children   = options.children || []

    super()

    @_data = {}

    Object.defineProperty @, 'data',
      get: ()->
        return @_data
      set: (data)->
        if data != @_data
          @trigger 'set', data
        @scheduleRender()
        return @_data

    @flows = _.extend {}, @flows
    @flows.render = @render

    @_flows = {}
    @_domEvents = {}

    @init.apply @, arguments
    @bindEvents()

    @data = data_

  init: ->

  render: (data, state)->
    if !@_dom?
      @_dom = createElement @_lastH
      if @root
        $(@selector).append @_dom

      for eventSpecStr, event of @_domEvents
        $(@_dom).on event.event, event.selector, event.handler

      @_h = @_lastH
    else
      patches = diff @_h, @_lastH
      @_dom = patch @_dom, patches
      @_h = @_lastH

    @_needsRender = false

    # Rerender children and reattach them
    for child in @children
      child.trigger 'render'
      $(@_dom).find(child.selector+':first').append child._dom

    return state.stale

  update: (templateFn)->
    return (data) ->
      # Generate the dom elements
      @_lastH = templateFn data
      return data

  bindEvents: ->
    for eventSpecStr, flow of @flows
      try
        eventSpec = parseEventSpec eventSpecStr
      catch error
        console.log error.message + ' while executing bindEvent'
        continue

      event     = eventSpec.event
      namespace = eventSpec.namespace
      selector  = eventSpec.selector

      do (eventSpecStr, event, namespace, selector, flow) =>
        if eventSpec.selector?
          if !(flowFn = @_flows[eventSpecStr])?
            flowFn = @_flows[eventSpecStr] = (e) =>
              staleData = @data
              data = $.extend true, {}, staleData
              state = new FlowState staleData, @_dom, e
              if !_.isArray flow
                flow = [flow]
              for fn in flow
                try
                  data = fn.call @, data, state
                catch error
                  console.log error.message + ' while executing ' + eventSpecStr
                  continue
              @data = data

          @on eventSpecStr, flowFn, namespace

          # dom event
          @_domEvents[eventSpecStr] =
            event:      event
            selector:   selector
            handler: (event)=>
              @trigger eventSpecStr, event
              event.stopPropagation()
        else
          if !(flowFn = @_flows[eventSpecStr])?
            flowFn = @_flows[eventSpecStr] = (data_) =>
              staleData = @data
              data = data_ || _.extend {}, staleData
              state = new FlowState staleData, @_dom, event
              if !_.isArray flow
                flow = [flow]
              for fn in flow
                try
                  data = fn.call @, data, state
                catch error
                  console.log error.message + ' while executing ' + eventSpecStr
                  continue

              # set is special event that need to bypass itself to prevent infinite loop
              if event == 'set'
                @_data = data
              else
                @data = data

          @on event, flowFn, namespace

  unbindEvents: ->
    @offAll()
    $(@_dom).off()

  delete: ->
    @unbindEvents()
    $(@_dom).remove()

  scheduleRender: ()->
    @_needsRender = true
    scheduledToRenderFlowControllers.unshift @

# Helpers
class EventSpec
  event: null
  namespace: null
  selector: null

  constructor: (@event, @namespace, @selector)->

parseEventSpec = (str)->
  tokens = str.split ' '
  if tokens.length > 1
    token0 = tokens.shift()
    tokens = [token0, tokens.join(' ')]

  switch tokens.length
    # Triggerable Event Case (event, no css selector)
    when 1
      eventToken = tokens[0]
      # extract namespace
      eventTokens = eventToken.split ':', 1
      switch eventTokens.length
        when 1
          return new EventSpec eventTokens[0]
        when 2
          return new EventSpec eventTokens[0], eventTokens[1]
    # Dom Event Case (event, css selector)
    when 2
      eventToken = tokens[0]
      #extract namespace
      selector = tokens[1]
      eventTokens = eventToken.split ':', 1
      switch eventTokens.length
        when 1
          return new EventSpec eventTokens[0], '', selector
        when 2
          return new EventSpec eventTokens[0], eventTokens[1], selector

  throw new Error 'Could not Parse Selector "' + str + '"'
