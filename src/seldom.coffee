# seldom.js
# Copyright (c) 2015 David Tai
#
#Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

# Requires Jquery

_               = require 'underscore'

diff            = require 'virtual-dom/diff'
patch           = require 'virtual-dom/patch'
createElement   = require 'virtual-dom/create-element'

html2hscript    = require 'html2hscript'

EventEmitter    = require './event'
premade         = require './premade'

module.exports = {}

# A FlowEvent is a custom event type generated by a FlowController's trigger method
class FlowEvent
  # name of event
  name: ''
  # data of event
  data: null

# A FlowState is a dictionary of meta data with some special fields (listed below)
class FlowState
  # data is data value before a flow is executed
  data: null
  # dom is the root dom object
  dom: null
  # event is a FlowEvent object if flow is triggered by an event
  event: null

  constructor: (@data, @dom, @event)->

# A FlowController maps events to 'flows' which are basically a list monadic binds
# to be executed by the FlowController monad
module.exports.FlowController = class FlowController extends EventEmitter
  # jquery/css selector for finding an element in a parent
  selector: ''

  # HScript root
  _h: null

  # Last rendered dom element
  _dom: null

  # Member storing the last data rendered, get this using .data
  _data: null

  # child flow controllers
  children: null

  # Internally stored dom event map to be used in unbinding dom events
  _domEvents: null

  # Define an event to flow mapping using Backbone style eventing syntax
  # Events can either be composed of a event name or an event name with a css selector.
  # The first case is for programmatically triggered events.  The second case is for
  # user driven events from the rendered dom.
  #
  # Flows are either a single function or a collection (array) of functions each
  # with the form of (data, state) -> returns processedData
  # where
  #  - 'data' is either the pre-Flow data passed when passed into the first function
  #    or the processedData from the previous function
  #  - 'state' contains a FlowState object
  #  - 'processedData' is the data to pass into the next function
  #    (typically a modified version of data)
  #
  # Each function's @ is set to its flow controller.  Note: It is ill-advised to add state
  # onto @, instead stick state onto the state object to make it scoped to the duration of
  # each flow.  @ is generally used to trigger things.
  #
  # Example
  # flows:
  #   'optional-namespace.event-name css.selector': userTriggedThing,
  #   'handle-input': [
  #     sanitize,
  #     validate,
  #     render,
  #   ]
  #
  flows:
    set: (data, state) ->
      premade.set
    render: [
      premade.higherOrder.log("No 'render' flow defined")
    ]

  # Used internally to store compiled flow functions
  _flows: null

  constructor: ->
    Object.defineProperty @, 'data',
      get: ()->
        return @_data
      set: (data)->
        return @trigger 'set', data

    @_flows = {}

    @init.apply @, arguments
    @bindEvents()

  init: ->

  render: (renderFunc, template)->
    return (data, state) ->
      # Generate the dom elements
      html = renderFunc template, data
      hs = html2hscript html
      if !@_dom?
        @_h = hs
        @_dom = createElement hs
      else
        patches = diff hs, @_h
        @_h = hs
        @_dom = patch @_dom, patches

      # Rerender children and reattach them
      for child in @children
        child.trigger 'render'
        @_dom.find $(@_dom).find(child.selector+':first').append(child._dom)

  bindEvents: ->
    for eventSpecStr, flow in @flows
      try
        eventSpec = parseEventSpec eventSpecStr
      catch error
        console.log error.message + ' while executing bindEvent'
        continue

      event     = eventSpec.event
      namespace = eventSpec.namespace
      selector  = eventSpec.selector

      if eventSpec.selector?
        if !(flowFn = @_flow[eventSpecStr])?
          do (event, namespace, selector, flow) ->
            flowFn = @_flow[eventSpecStr] = (e) =>
              staleData = @data
              data = _.extend {}, staleData
              state = new State staleData, @_dom, event
              for fn in flow
                try
                  data = fn data, state
                catch error
                  console.log error.message + ' while executing ' + eventSpecStr
                  continue
              @data = data

        @on event, flowFn, namespace
      else
        if !(flowFn = @_flow[eventSpecStr])?
          do (event, namespace, flow) ->
            flowFn = @_flow[eventSpecStr] = (data_) =>
              staleData = @data
              data = data_ || _.extend {}, staleData
              state = new State staleData, @_dom, event
              for fn in flow
                try
                  data = fn data, state
                catch error
                  console.log error.message + ' while executing ' + eventSpecStr
                  continue
              @data = data

        @on event, flowFn, namespace

  unbindEvents: ->
    @offAll()

# Helpers
class EventSpec
  event: null
  namespace: null
  selector: null

  cosntructor: (@event, @namespace, @selector)->

parseEventSpec = (str)->
  tokens = str.split ' ', 1

  switch tokens.length
    # Triggerable Event Case (event, no css selector)
    when 1
      eventToken = tokens[0]
      eventTokens = eventToken.split '.', 1
      switch eventTokens.length
        when 1
          return new EventSpec eventTokens[0]
        when 2
          return new EventSpec eventTokens[0], eventTokens[1]
    when 2
    # Dom Event Case (event, no css selector)
      eventToken = tokens[0]
      selector = tokens[1]
      switch eventTokens.length
        when 1
          return new EventSpec eventTokens[0], '', selector
        when 2
          return new EventSpec eventTokens[0], eventTokens[1], selector

  throw new Error 'Could not Parse Selector "' + str + '"'
